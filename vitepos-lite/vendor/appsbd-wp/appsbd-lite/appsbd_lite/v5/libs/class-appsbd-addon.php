<?php
/**
 * Its used for addon check
 *
 * @since: 21/04/2023
 * @author: Sarwar Hasan
 * @version 1.0.0
 * @package VitePos\Libs
 */

namespace Appsbd_Lite\V5\libs;

use VitePos_Lite\Libs\Vitepos_Loader;
use VitePos_Lite\Libs\WP_Error;
use function VitePos_Lite\Libs\vtp_dci_dynamic_init;

if ( ! class_exists( __NAMESPACE__ . '\Appsbd_Addon' ) ) {
	/**
	 * Class Vitepos_Loader
	 *
	 * @package VitePos\Libs
	 */
	class Appsbd_Addon {

		/**
		 * The clean request is generated by appsbd
		 */
		public static function clean_request() {
			$hooks = [
				'http_request_args',
				'pre_http_request',
				'http_api_debug',
				'requests-curl.before_request',
				'requests-curl.after_request',
				'requests-fsockopen.before_request',
				'requests-fsockopen.after_request'
			];
			foreach ( $hooks as $hook ) {
				remove_all_filters( $hook );
			}
		}

		/**
		 * The clean bearer is generated by appsbd
		 *
		 * @param mixed $b It is b param.
		 */
		private static function clean_bearer( &$b, $pid ) {
			/**
			 * It's for check is there any change before process
			 *
			 * @since 3.0
			 */
			$b = apply_filters( 'appsbd/filter/clean-bearer', $b, 'apbdaddonenc_' . $pid );
		}

		/**
		 * Retrieves the referring URL.
		 *
		 * @since 3.0
		 *
		 * @return string The referring URL.
		 */
		public static function get_referer() {
			if ( defined( 'WPINC' ) && function_exists( 'get_bloginfo' ) ) {
				return get_bloginfo( 'url' );
			} else {
				return AppInput::current_url();
			}
		}

		/**
		 * Fetches and processes addon data from a remote server.
		 *
		 * @param string $id The ID of the addon to fetch.
		 * @param string $prefix Optional. The prefix used for the WordPress option. Default is an empty string.
		 * @param bool $result Optional. Determines the type of request. Default is false.
		 *
		 * @return mixed The decoded addons data if the request is successful, null otherwise.
		 *
		 * @since 3.0.4
		 */
		public static function addon_list( $id, $prefix = '', $result = false ) {
			$url = 'https://addon.appsbd.com/addons/' . $id;

			/**
			 * Its for check is there any change before process
			 *
			 * @since 3.0.4
			 */
			$bearer = apply_filters( 'appsbd/filter/bearer', '' );
			$args   = array(
				'sslverify'   => true,
				'timeout'     => 120,
				'redirection' => 5,
				'cookies'     => array(),
				'headers'     => array(
					'Referer' => self::get_referer(),
				),
			);
			if ( ! empty( $bearer ) ) {
				self::clean_bearer( $bearer, $id );
				$args['headers']['Authorization'] = 'Bearer ' . $bearer;
			}
			self::clean_request();

			$type = ( $result ? 'a' : 'b' );
			/**
			 * Its for check is there any change before process
			 *
			 * @since 3.0.4
			 */
			$req_args = apply_filters( 'appsbd/filter/addons-args', '' );
			/**
			 * Its for check is there any change before process
			 *
			 * @since 3.0.4
			 */
			$pid = apply_filters( 'appsbd/filter/pid', array() );

			$url = $url . '?t=' . $type;
			if ( ! empty( $pid ) && is_array( $pid ) ) {
				$url = $url . '&c=' . implode( '-', $pid );
			}
			if ( ! empty( $req_args ) ) {
				$url = $url . '&' . $req_args;
			}
			$response = wp_remote_get( $url, $args );
			if ( is_wp_error( $response ) ) {
				$args['sslverify'] = false;
				$response          = wp_remote_get( $url, $args );
			}
			if ( ! is_wp_error( $response ) && ! empty( $response['body'] ) ) {
				if ( empty( $prefix ) ) {
					$prefix = $id;
				}
				$addons = json_decode( $response['body'] );
				update_option( $prefix . '_addons', $addons );

				return $addons;

			}
		}
	}
}
